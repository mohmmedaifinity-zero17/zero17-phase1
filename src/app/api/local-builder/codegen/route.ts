// src/app/api/local-builder/codegen/route.ts
import { NextRequest, NextResponse } from "next/server";
import path from "path";
import fs from "fs/promises";

/**
 * Types mirrored from the Builder UI.
 * These must match src/app/builder/page.tsx.
 */

type BuildType = "app" | "agent" | "dashboard" | "workflow";

type ArchitectureEntityKind = "data" | "service" | "external";

interface ArchitectureEntity {
  id: string;
  name: string;
  description: string;
  kind: ArchitectureEntityKind;
  notes: string;
}

interface AgentDefinition {
  id: string;
  name: string;
  mission: string;
  persona: string;
  tools: string;
  handoffs: string;
}

interface BuilderProjectPayload {
  id: string;
  title: string;
  description?: string;
  buildType: BuildType;
  architecture?: ArchitectureEntity[];
  agents?: AgentDefinition[];
}

/* -------------------------------------------------------------------------- */
/*  FS helpers                                                                */
/* -------------------------------------------------------------------------- */

async function ensureDir(dir: string) {
  await fs.mkdir(dir, { recursive: true });
}

async function cleanDir(dir: string) {
  try {
    await fs.rm(dir, { recursive: true, force: true });
  } catch {
    // ignore
  }
  await ensureDir(dir);
}

/* -------------------------------------------------------------------------- */
/*  Identifier helpers                                                        */
/* -------------------------------------------------------------------------- */

function toSafeIdentifier(input: string, fallback: string): string {
  const trimmed = input.trim();
  if (!trimmed) return fallback;

  let cleaned = trimmed
    .normalize("NFKD")
    .replace(/[^\w\s]/g, " ")
    .replace(/\s+/g, " ")
    .trim();

  if (!cleaned) return fallback;

  const parts = cleaned.split(" ");
  const pascal = parts
    .map((p) => p.charAt(0).toUpperCase() + p.slice(1).toLowerCase())
    .join("");
  let camel = pascal.charAt(0).toLowerCase() + pascal.slice(1);

  if (!/^[A-Za-z_]/.test(camel)) {
    camel = `x${camel}`;
  }
  return camel;
}

function toSafeSqlIdentifier(input: string, fallback: string): string {
  const trimmed = input.trim();
  if (!trimmed) return fallback;

  let cleaned = trimmed
    .normalize("NFKD")
    .replace(/[^\w\s]/g, " ")
    .replace(/\s+/g, " ")
    .trim()
    .toLowerCase();

  if (!cleaned) return fallback;

  let snake = cleaned.replace(/\s+/g, "_");
  snake = snake.replace(/[^a-z0-9_]/g, "_");

  if (/^[0-9]/.test(snake)) {
    snake = `t_${snake}`;
  }

  if (!snake) return fallback;
  return snake;
}

/* -------------------------------------------------------------------------- */
/*  schema.ts codegen                                                         */
/* -------------------------------------------------------------------------- */

function generateSchemaModule(params: {
  project: BuilderProjectPayload;
  entities: ArchitectureEntity[];
}): string {
  const { project, entities } = params;

  const header = `/**
 * Auto-generated by Zero17 Builder Lab
 * Project: ${project.title}
 * Build type: ${project.buildType}
 * 
 * NOTE:
 * - Edit this file if you want to refine the data / service layout.
 * - Re-running codegen will overwrite it, so keep your source of truth
 *   in the Builder Lab UI or move this file and import from there.
 */

export type EntityKind = "data" | "service" | "external";

export interface Entity {
  id: string;
  name: string;
  kind: EntityKind;
  description: string;
  notes?: string;
}

/**
 * High-level system map. Each entity is either:
 * - "data": database / store / model
 * - "service": internal service or domain
 * - "external": third-party API / system
 */
export const ENTITIES: Entity[] = [
`;

  const body =
    entities.length === 0
      ? `  // No entities defined yet. Add them from the Builder Lab architecture panel.
`
      : entities
          .map((e) => {
            const safeName = e.name || "Untitled entity";
            const safeDesc =
              e.description ||
              "Describe what this owns or does, and its relationships.";
            const safeNotes = e.notes || "";

            const escDesc = safeDesc
              .replace(/\\/g, "\\\\")
              .replace(/`/g, "\\`");
            const escNotes = safeNotes
              .replace(/\\/g, "\\\\")
              .replace(/`/g, "\\`");

            return `  {
    id: "${e.id}",
    name: "${safeName.replace(/"/g, '\\"')}",
    kind: "${e.kind}",
    description: \`${escDesc}\`,
    notes: ${escNotes ? "`" + escNotes + "`" : "undefined"},
  },`;
          })
          .join("\n");

  const footer = `
];

/**
 * Convenience lookup by id.
 */
export const ENTITY_BY_ID: Record<string, Entity> = Object.fromEntries(
  ENTITIES.map((e) => [e.id, e])
);
`;

  return header + body + footer;
}

/* -------------------------------------------------------------------------- */
/*  agents.ts codegen                                                         */
/* -------------------------------------------------------------------------- */

function generateAgentsModule(params: {
  project: BuilderProjectPayload;
  agents: AgentDefinition[];
}): string {
  const { project, agents } = params;

  const header = `/**
 * Auto-generated by Zero17 Builder Lab
 * Project: ${project.title}
 * Build type: ${project.buildType}
 * 
 * Agent employees: each one is a "teammate" with:
 * - mission: what they own end-to-end
 * - persona: how they behave / decide
 * - tools: APIs / data sources they can call
 * - handoffs: where they pass work to humans or other agents
 */

export interface AgentConfig {
  id: string;
  name: string;
  mission: string;
  persona: string;
  tools: string;
  handoffs: string;
}

/**
 * Flat list of agent employees.
 */
export const AGENTS: AgentConfig[] = [
`;

  const body =
    agents.length === 0
      ? `  // No agents defined yet. Add them from the Builder Lab agents panel.
`
      : agents
          .map((a) => {
            const safeName = a.name || "Untitled agent";
            const safeMission =
              a.mission ||
              "Clarify this agent's mission: what are they accountable for?";
            const safePersona =
              a.persona ||
              "Describe attitude, risk profile, decision style (e.g. ruthless prioritizer).";
            const safeTools =
              a.tools ||
              "List the tools/APIs/data this agent can call (e.g. email API, Notion DB).";
            const safeHandoffs =
              a.handoffs ||
              "Describe when this agent hands off to another agent or a human.";

            const escMission = safeMission
              .replace(/\\/g, "\\\\")
              .replace(/`/g, "\\`");
            const escPersona = safePersona
              .replace(/\\/g, "\\\\")
              .replace(/`/g, "\\`");
            const escTools = safeTools
              .replace(/\\/g, "\\\\")
              .replace(/`/g, "\\`");
            const escHandoffs = safeHandoffs
              .replace(/\\/g, "\\\\")
              .replace(/`/g, "\\`");

            return `  {
    id: "${a.id}",
    name: "${safeName.replace(/"/g, '\\"')}",
    mission: \`${escMission}\`,
    persona: \`${escPersona}\`,
    tools: \`${escTools}\`,
    handoffs: \`${escHandoffs}\`,
  },`;
          })
          .join("\n");

  const footer = `
];

/**
 * Simple lookup by id.
 */
export const AGENT_BY_ID: Record<string, AgentConfig> = Object.fromEntries(
  AGENTS.map((a) => [a.id, a])
);
`;

  return header + body + footer;
}

/* -------------------------------------------------------------------------- */
/*  app/page.tsx scaffold                                                     */
/* -------------------------------------------------------------------------- */

function generateAppPageModule(params: {
  project: BuilderProjectPayload;
}): string {
  const { project } = params;
  const slug = toSafeIdentifier(project.title, "zero17Build");

  return `/**
 * Auto-generated by Zero17 Builder Lab
 * 
 * This is a tiny shell that imports the generated schema + agents.
 * You can now open this app, and then iteratively refine from here.
 */

import { ENTITIES } from "../lib/schema";
import { AGENTS } from "../lib/agents";

export default function Page() {
  return (
    <main className="min-h-screen bg-slate-950 text-slate-50 px-6 py-8">
      <div className="max-w-5xl mx-auto space-y-6">
        <header className="flex items-center justify-between gap-4">
          <div>
            <p className="text-xs uppercase tracking-wide text-emerald-300">
              Zero17 • Generated build
            </p>
            <h1 className="text-lg font-semibold text-slate-50">
              ${project.title}
            </h1>
            ${
              project.description
                ? `<p className="text-xs text-slate-400 mt-1">
              ${project.description.replace(/"/g, '\\"')}
            </p>`
                : ""
            }
          </div>
          <div className="text-right text-[10px] text-slate-400">
            <p>Slug: <span className="font-mono">${slug}</span></p>
            <p>Type: ${project.buildType}</p>
          </div>
        </header>

        <section className="rounded-2xl border border-slate-800 bg-slate-950/80 px-4 py-3 space-y-2">
          <h2 className="text-sm font-semibold text-slate-100">
            System map
          </h2>
          <p className="text-[11px] text-slate-400">
            Entities and services defined in Builder Lab. This is a starting
            point for your data model and service boundaries.
          </p>
          <div className="mt-2 space-y-1.5">
            {ENTITIES.length === 0 ? (
              <p className="text-[11px] text-slate-500">
                No entities defined yet. Go back to Builder Lab → Architecture
                and define some first.
              </p>
            ) : (
              ENTITIES.map((e) => (
                <div
                  key={e.id}
                  className="flex items-start justify-between gap-3 rounded-lg border border-slate-800 bg-slate-950 px-3 py-2"
                >
                  <div className="space-y-0.5">
                    <p className="text-[11px] font-semibold text-slate-100">
                      {e.name}{" "}
                      <span className="text-[9px] uppercase tracking-wide text-slate-500">
                        • {e.kind}
                      </span>
                    </p>
                    <p className="text-[10px] text-slate-400 whitespace-pre-line">
                      {e.description}
                    </p>
                    {e.notes && (
                      <p className="text-[10px] text-slate-500 whitespace-pre-line">
                        {e.notes}
                      </p>
                    )}
                  </div>
                </div>
              ))
            )}
          </div>
        </section>

        <section className="rounded-2xl border border-slate-800 bg-slate-950/80 px-4 py-3 space-y-2">
          <h2 className="text-sm font-semibold text-slate-100">
            Agent employees
          </h2>
          <p className="text-[11px] text-slate-400">
            AI teammates defined in Builder Lab. Wire these into a real agent
            runtime (LangGraph, etc.) from here.
          </p>
          <div className="mt-2 space-y-1.5">
            {AGENTS.length === 0 ? (
              <p className="text-[11px] text-slate-500">
                No agents defined yet. Use Builder Lab → Agent employees to add some.
              </p>
            ) : (
              AGENTS.map((a) => (
                <div
                  key={a.id}
                  className="rounded-lg border border-slate-800 bg-slate-950 px-3 py-2 space-y-1"
                >
                  <p className="text-[11px] font-semibold text-slate-100">
                    {a.name}
                  </p>
                  <p className="text-[10px] text-slate-300 whitespace-pre-line">
                    {a.mission}
                  </p>
                  <p className="text-[10px] text-slate-400 whitespace-pre-line">
                    Persona: {a.persona}
                  </p>
                  <p className="text-[10px] text-slate-400 whitespace-pre-line">
                    Tools: {a.tools}
                  </p>
                  <p className="text-[10px] text-slate-500 whitespace-pre-line">
                    Handoffs: {a.handoffs}
                  </p>
                </div>
              ))
            )}
          </div>
        </section>
      </div>
    </main>
  );
}
`;
}

/* -------------------------------------------------------------------------- */
/*  db/schema.sql codegen                                                     */
/* -------------------------------------------------------------------------- */

function generateSqlSchema(params: {
  project: BuilderProjectPayload;
  entities: ArchitectureEntity[];
}): string {
  const { project, entities } = params;

  const header = `-- Auto-generated by Zero17 Builder Lab
-- Project: ${project.title}
-- Build type: ${project.buildType}
--
-- This is a starting point for your Postgres / Supabase schema.
-- Convention:
--   - Only entities with kind = 'data' are mapped to tables by default.
--   - Others ("service", "external") are documented as comments.
--   - Each table starts with:
--       id          uuid PRIMARY KEY DEFAULT gen_random_uuid()
--       created_at  timestamptz NOT NULL DEFAULT now()
--       updated_at  timestamptz NOT NULL DEFAULT now()
--       payload     jsonb NOT NULL DEFAULT '{}'::jsonb
--
-- You should refine this schema by:
--   - Extracting real columns from "payload"
--   - Adding indexes, FKs, constraints, etc.
--
-- NOTE: Re-running codegen will overwrite this file.

`;

  const parts: string[] = [];

  entities.forEach((e) => {
    const kind = e.kind;
    const desc = e.description || "";
    const notes = e.notes || "";
    const baseName =
      e.name || (kind === "data" ? `Data entity ${e.id}` : `Entity ${e.id}`);
    const tableName = toSafeSqlIdentifier(baseName, `t_${e.id.slice(-6)}`);

    if (kind === "data") {
      parts.push(`-- Entity: ${baseName}
-- Kind: data
-- Description: ${desc.replace(/\r?\n/g, " ")}
${notes ? `-- Notes: ${notes.replace(/\r?\n/g, " ")}` : ""}
CREATE TABLE IF NOT EXISTS "${tableName}" (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  payload jsonb NOT NULL DEFAULT '{}'::jsonb
);

`);
    } else {
      parts.push(`-- Entity: ${baseName}
-- Kind: ${kind}
-- Description: ${desc.replace(/\r?\n/g, " ")}
${notes ? `-- Notes: ${notes.replace(/\r?\n/g, " ")}` : ""}

`);
    }
  });

  if (parts.length === 0) {
    parts.push(
      `-- No entities defined yet.
-- Once you add "data" entities in Builder Lab → Architecture,
-- this file will emit corresponding CREATE TABLE statements.

`
    );
  }

  return header + parts.join("\n");
}

/* -------------------------------------------------------------------------- */
/*  agents/runtime.ts codegen (graph runner)                                  */
/* -------------------------------------------------------------------------- */

function generateAgentRuntimeModule(params: {
  project: BuilderProjectPayload;
  agents: AgentDefinition[];
}): string {
  const { project } = params;

  const header = `/**
 * Auto-generated by Zero17 Builder Lab
 * Project: ${project.title}
 * Build type: ${project.buildType}
 *
 * This file is a "runtime surface" for your agent employees.
 * It combines:
 *  - AgentRuntimeConfig (nodes + edges)
 *  - A minimal graph runner you can plug into any LLM
 *
 * It does NOT import a specific agent framework. Instead, you pass a
 * \`callLLM\` function that wraps OpenAI, Anthropic, LangGraph nodes, etc.
 */

import { AGENTS } from "../lib/agents";

export interface AgentNodeConfig {
  id: string;
  name: string;
  mission: string;
  persona: string;
  tools: string;
  handoffs: string;
}

export interface AgentEdgeConfig {
  fromId: string;
  toId: string;
  reason: string;
}

export interface AgentRuntimeConfig {
  nodes: AgentNodeConfig[];
  edges: AgentEdgeConfig[];
}

export interface AgentRunStep {
  id: string;
  agentId: string;
  agentName: string;
  input: string;
  output: string;
}

export interface AgentRunTrace {
  input: string;
  steps: AgentRunStep[];
}

/**
 * Generic LLM call signature. Plug in your own implementation
 * using OpenAI, Anthropic, local models, or a LangGraph node.
 */
export type LLMCall = (args: {
  agent: AgentNodeConfig;
  input: string;
  context?: Record<string, unknown>;
}) => Promise<string>;

/**
 * Convert the flat AGENTS list into runtime config.
 * For now, edges are empty; you can fill them manually
 * or write a parser that turns AGENTS[].handoffs into connections.
 */
export function buildAgentRuntimeConfig(): AgentRuntimeConfig {
  const nodes: AgentNodeConfig[] = AGENTS.map((a) => ({
    id: a.id,
    name: a.name,
    mission: a.mission,
    persona: a.persona,
    tools: a.tools,
    handoffs: a.handoffs,
  }));

  const edges: AgentEdgeConfig[] = [
    // Example (replace with your real edges):
    // {
    //   fromId: "agent-1",
    //   toId: "agent-2",
    //   reason: "Agent 1 triages and then hands execution to Agent 2."
    // }
  ];

  return { nodes, edges };
}

/**
 * Minimal multi-step graph runner.
 *
 * By default, it:
 * - Picks a starting agent (by id or the first one),
 * - Runs up to \`maxSteps\` turns,
 * - Cycles through nodes in order (or you can customize edge traversal),
 * - Calls your \`callLLM\` implementation per step.
 *
 * You can plug this into a LangGraph setup by:
 * - Using AgentRuntimeConfig to define graph nodes,
 * - Translating AgentEdgeConfig into graph edges,
 * - Replacing this runner with the LangGraph execution engine.
 */
export async function runAgentGraph(params: {
  config?: AgentRuntimeConfig;
  input: string;
  startAgentId?: string;
  maxSteps?: number;
  callLLM: LLMCall;
}): Promise<AgentRunTrace> {
  const { config: providedConfig, input, startAgentId, maxSteps = 4, callLLM } = params;

  const config = providedConfig ?? buildAgentRuntimeConfig();
  const { nodes } = config;

  if (!nodes.length) {
    return { input, steps: [] };
  }

  const startIndex =
    startAgentId != null
      ? Math.max(
          0,
          nodes.findIndex((n) => n.id === startAgentId || n.name === startAgentId)
        )
      : 0;

  const steps: AgentRunStep[] = [];
  let currentIndex = startIndex < 0 ? 0 : startIndex;
  let currentInput = input;

  const totalSteps = Math.min(maxSteps, nodes.length || 1);

  for (let i = 0; i < totalSteps; i++) {
    const node = nodes[currentIndex];
    const output = await callLLM({
      agent: node,
      input: currentInput,
      context: {
        stepIndex: i,
        totalSteps,
      },
    });

    steps.push({
      id: \`step_\${i}\`,
      agentId: node.id,
      agentName: node.name,
      input: currentInput,
      output,
    });

    currentInput = output;
    currentIndex = (currentIndex + 1) % nodes.length;
  }

  return { input, steps };
}

/**
 * Example: OpenAI-style callLLM (pseudo-code).
 *
 * Implement this in your own runtime, not here:
 *
 *   import OpenAI from "openai";
 *   const client = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
 *
 *   const callLLM: LLMCall = async ({ agent, input }) => {
 *     const res = await client.chat.completions.create({
 *       model: "gpt-4.1-mini",
 *       messages: [
 *         {
 *           role: "system",
 *           content: [
 *             "You are an AI agent employee.",
 *             "Mission: " + agent.mission,
 *             "Persona: " + agent.persona,
 *             "You can access tools: " + agent.tools,
 *             "You hand off when: " + agent.handoffs,
 *           ].join("\\n"),
 *         },
 *         { role: "user", content: input },
 *       ],
 *     });
 *     return res.choices[0]?.message?.content ?? "";
 *   };
 *
 * Then:
 *
 *   const config = buildAgentRuntimeConfig();
 *   const trace = await runAgentGraph({
 *     config,
 *     input: "Start-of-day founder briefing",
 *     maxSteps: 3,
 *     callLLM,
 *   });
 *
 * This keeps your runtime wiring declarative and generated.
 */
`;

  return header;
}

/* -------------------------------------------------------------------------- */
/*  Route handler                                                             */
/* -------------------------------------------------------------------------- */

export async function POST(req: NextRequest) {
  try {
    const body = await req.json();

    const project: BuilderProjectPayload | undefined = body?.project;
    if (!project || !project.id || !project.title || !project.buildType) {
      return NextResponse.json(
        { ok: false, error: "Missing or invalid project payload." },
        { status: 400 }
      );
    }

    const architecture: ArchitectureEntity[] = project.architecture ?? [];
    const agents: AgentDefinition[] = project.agents ?? [];

    const rootDir = path.join(
      process.cwd(),
      "generated-local",
      project.id.replace(/[^a-zA-Z0-9_-]/g, "_")
    );

    await cleanDir(rootDir);

    const appDir = path.join(rootDir, "app");
    const libDir = path.join(rootDir, "lib");
    const dbDir = path.join(rootDir, "db");
    const agentsDir = path.join(rootDir, "agents");

    await ensureDir(appDir);
    await ensureDir(libDir);
    await ensureDir(dbDir);
    await ensureDir(agentsDir);

    const files: string[] = [];

    // 1) schema.ts
    const schemaPath = path.join(libDir, "schema.ts");
    const schemaSource = generateSchemaModule({
      project,
      entities: architecture,
    });
    await fs.writeFile(schemaPath, schemaSource, "utf8");
    files.push("lib/schema.ts");

    // 2) agents.ts
    const agentsPath = path.join(libDir, "agents.ts");
    const agentsSource = generateAgentsModule({ project, agents });
    await fs.writeFile(agentsPath, agentsSource, "utf8");
    files.push("lib/agents.ts");

    // 3) app/page.tsx shell
    const pagePath = path.join(appDir, "page.tsx");
    const pageSource = generateAppPageModule({ project });
    await fs.writeFile(pagePath, pageSource, "utf8");
    files.push("app/page.tsx");

    // 4) db/schema.sql
    const sqlPath = path.join(dbDir, "schema.sql");
    const sqlSource = generateSqlSchema({ project, entities: architecture });
    await fs.writeFile(sqlPath, sqlSource, "utf8");
    files.push("db/schema.sql");

    // 5) agents/runtime.ts (runtime config + graph runner)
    const runtimePath = path.join(agentsDir, "runtime.ts");
    const runtimeSource = generateAgentRuntimeModule({ project, agents });
    await fs.writeFile(runtimePath, runtimeSource, "utf8");
    files.push("agents/runtime.ts");

    // 6) README
    const readmePath = path.join(rootDir, "ZERO17-GENERATED.md");
    const readme = `# Zero17 Generated Build

Project: ${project.title}
Type: ${project.buildType}

This folder was created by Zero17 Builder Lab.

Generated pieces:

- lib/schema.ts
  High-level system map (entities, kinds, descriptions, notes).

- lib/agents.ts
  Agent employees (mission, persona, tools, handoffs).

- app/page.tsx
  Minimal Next.js shell that displays ENTITIES and AGENTS.

- db/schema.sql
  Starter Postgres / Supabase schema for "data" entities.

- agents/runtime.ts
  AgentRuntimeConfig + runAgentGraph(…) to plug into your LLM runtime.

You can now:
- Refine ENTITIES into concrete DB tables (columns, FKs, indexes).
- Wire AGENTS into a multi-agent runtime via agents/runtime.ts.
- Evolve app/page.tsx into your production UI.

Re-running codegen from Builder Lab will overwrite files in this folder.
If you want to keep manual edits, move the files elsewhere and import them.
`;
    await fs.writeFile(readmePath, readme, "utf8");
    files.push("ZERO17-GENERATED.md");

    return NextResponse.json({
      ok: true,
      rootDir,
      files,
    });
  } catch (err: any) {
    console.error("[local-builder:codegen] error", err);
    return NextResponse.json(
      {
        ok: false,
        error: err?.message || "Unexpected error in codegen route.",
      },
      { status: 500 }
    );
  }
}
