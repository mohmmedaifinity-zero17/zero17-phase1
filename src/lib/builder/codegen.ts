// src/lib/builder/codegen.ts

import * as fs from "fs/promises";
import * as path from "path";
import type {
  BuilderProject,
  MultiLensSpec,
  ArchitectureMap,
  ArchitectureScreen,
  ArchitectureEntity,
} from "@/lib/builder/types";

export type GeneratedFile = {
  /** Path relative to the project-specific root, e.g. "app/page.tsx" */
  path: string;
  contents: string;
};

export type WriteResult = {
  rootDir: string;
  fileCount: number;
};

function slugify(name: string): string {
  return (
    name
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, "-")
      .replace(/^-+|-+$/g, "")
      .trim() || "page"
  );
}

function pascalCase(input: string): string {
  return input
    .split(/[^a-zA-Z0-9]+/g)
    .filter(Boolean)
    .map((word) => word[0]?.toUpperCase() + word.slice(1).toLowerCase())
    .join("");
}

/**
 * Generate a minimal but real Next.js app scaffold for the given project.
 *
 * This does NOT try to be perfect UI — goal is:
 * - Compilable Next.js app
 * - Screens for each Architecture screen
 * - Simple CX dashboard on the root
 * - Basic data wiring against generated API routes
 */
export function generateProjectScaffold(
  project: BuilderProject,
  spec: MultiLensSpec,
  architecture: ArchitectureMap
): GeneratedFile[] {
  const files: GeneratedFile[] = [];

  const projectName = project.title || "Zero17 Project";
  const oneLiner =
    spec.clientLens?.whatYouGet?.[0] ||
    spec.founderLens?.problem ||
    "Generated by Zero17 Builder Lab";

  const primaryEntity: ArchitectureEntity | undefined =
    architecture.entities?.[0];
  const primaryEntitySlug = primaryEntity
    ? slugify(primaryEntity.name || "item")
    : null;
  const primaryEntityLabel = primaryEntity?.name || "Item";

  // --- Root layout ------------------------------------------------------
  const layoutTsx = `import "./globals.css";
import type { ReactNode } from "react";

export const metadata = {
  title: "${projectName}",
  description: "${oneLiner.replace(/"/g, "'")}",
};

export default function RootLayout({ children }: { children: ReactNode }) {
  return (
    <html lang="en">
      <body className="min-h-screen bg-slate-950 text-slate-50">
        <div className="mx-auto flex min-h-screen max-w-5xl flex-col px-4 py-6">
          <header className="mb-6 flex items-center justify-between gap-4 border-b border-slate-800 pb-4">
            <div>
              <h1 className="text-xl font-semibold tracking-tight">
                ${projectName}
              </h1>
              <p className="mt-1 text-xs text-slate-400">
                ${oneLiner.replace(/"/g, "'")}
              </p>
            </div>
            <span className="rounded-full border border-emerald-500/40 bg-emerald-900/20 px-3 py-1 text-[10px] font-medium text-emerald-200">
              Generated by Zero17 · Builder Lab
            </span>
          </header>
          <main className="flex-1">{children}</main>
          <footer className="mt-6 border-t border-slate-900 pt-3 text-[10px] text-slate-500">
            <span>Zero17 · Generated scaffold. Extend, refactor and own it.</span>
          </footer>
        </div>
      </body>
    </html>
  );
}
`;

  files.push({
    path: "app/layout.tsx",
    contents: layoutTsx,
  });

  // --- Root dashboard page ---------------------------------------------
  const dashboardBullets = (spec.clientLens?.whatYouGet || [])
    .slice(0, 4)
    .map(
      (item) =>
        `          <li className="text-xs text-slate-300">• ${item}</li>`
    )
    .join("\n");

  const rootScreenLinks = architecture.screens
    .slice(0, 6)
    .map((screen) => {
      const slug = slugify(screen.name);
      return `        <a
          href="/${slug}"
          className="block rounded-xl border border-slate-800 bg-slate-950/60 px-3 py-2 text-xs hover:border-sky-500 hover:bg-slate-900"
        >
          <div className="flex items-center justify-between gap-2">
            <span className="font-medium text-slate-100">${screen.name}</span>
            <span className="text-[10px] uppercase tracking-wide text-slate-500">Screen</span>
          </div>
          <p className="mt-1 line-clamp-2 text-[11px] text-slate-400">
            ${screen.purpose || ""}
          </p>
        </a>`;
    })
    .join("\n\n");

  const primaryImport = primaryEntitySlug
    ? `import PrimaryEntityPanel from "./components/PrimaryEntityPanel";\n\n`
    : "";

  const primarySection = primaryEntitySlug
    ? `
      <section className="rounded-2xl border border-slate-800 bg-slate-950/80 p-4">
        <div className="mb-3 flex items-center justify-between gap-2">
          <h3 className="text-xs font-semibold uppercase tracking-wide text-slate-400">
            Quick ${primaryEntityLabel}
          </h3>
          <span className="text-[10px] text-slate-500">
            Live data via /api/${primaryEntitySlug}
          </span>
        </div>
        <PrimaryEntityPanel />
      </section>`
    : "";

  const pageTsx = `${primaryImport}export default function Page() {
  return (
    <div className="space-y-6">
      <section className="rounded-2xl border border-slate-800 bg-slate-950/80 p-4">
        <h2 className="text-sm font-semibold text-slate-100">Command Deck</h2>
        <p className="mt-1 text-xs text-slate-400">
          High-level overview of your product. This is a starting point — feel free to
          evolve it into the true home screen of your app.
        </p>
        ${
          dashboardBullets
            ? `\n        <ul className="mt-3 space-y-1">\n${dashboardBullets}\n        </ul>\n`
            : ""
        }
      </section>

      <section className="rounded-2xl border border-slate-800 bg-slate-950/80 p-4">
        <div className="mb-3 flex items-center justify-between gap-2">
          <h3 className="text-xs font-semibold uppercase tracking-wide text-slate-400">
            Screens
          </h3>
          <span className="text-[10px] text-slate-500">
            Generated from Architecture Map
          </span>
        </div>
        <div className="grid gap-2 md:grid-cols-2">
${
  rootScreenLinks ||
  `          <p className="text-[11px] text-slate-500">No screens defined yet. Use the Architecture Map to add them.</p>`
}
        </div>
      </section>${primarySection}
    </div>
  );
}
`;

  files.push({
    path: "app/page.tsx",
    contents: pageTsx,
  });

  // --- Screen pages ----------------------------------------------------
  architecture.screens.forEach((screen: ArchitectureScreen) => {
    const slug = slugify(screen.name);
    const componentName = pascalCase(slug) || "Screen";

    const screenPage = `type ScreenProps = {};

export default function ${componentName}(props: ScreenProps) {
  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between gap-2">
        <div>
          <h2 className="text-sm font-semibold text-slate-100">${screen.name}</h2>
          <p className="mt-1 text-xs text-slate-400">
            ${screen.purpose || "Screen generated from Architecture Map."}
          </p>
        </div>
        <a
          href="/"
          className="text-[11px] text-sky-400 hover:text-sky-300 underline-offset-2 hover:underline"
        >
          ← Back to Command Deck
        </a>
      </div>

      <div className="rounded-xl border border-slate-800 bg-slate-950/80 p-4">
        <p className="text-[11px] text-slate-400">
          This is a scaffold. Replace with real components and data wiring.
        </p>
      </div>
    </div>
  );
}
`;

    files.push({
      path: `app/${slug}/page.tsx`,
      contents: screenPage,
    });
  });

  // --- Domain types from entities --------------------------------------
  if (architecture.entities.length > 0) {
    const entityBlocks = architecture.entities
      .map((entity: ArchitectureEntity) => {
        const interfaceName = pascalCase(entity.name || "Entity");
        const fieldLines =
          entity.fields && entity.fields.length > 0
            ? entity.fields.map((f) => {
                const fieldName = f.name || "field";
                const fieldType =
                  f.type === "number"
                    ? "number"
                    : f.type === "boolean"
                      ? "boolean"
                      : "string";
                return `  ${fieldName}: ${fieldType};`;
              })
            : [`  id: string;`, `  createdAt?: string;`];

        return `export interface ${interfaceName} {
${fieldLines.join("\n")}
}`;
      })
      .join("\n\n");

    const domainTs = `// Domain entities generated from Architecture Map.
// Extend / refine these manually as your product matures.

${entityBlocks}
`;

    files.push({
      path: "lib/domain/entities.ts",
      contents: domainTs,
    });
  }

  // --- API routes for entities -----------------------------------------
  architecture.entities.forEach((entity: ArchitectureEntity) => {
    const slug = slugify(entity.name || "item");
    const apiRoute = `import { NextResponse } from "next/server";

export const runtime = "nodejs";

// Simple in-memory store for local dev / prototyping.
// Replace with a real database (Supabase / Postgres / etc) when you wire persistence.
let memoryStore: any[] = [];

export async function GET() {
  return NextResponse.json(memoryStore);
}

export async function POST(req: Request) {
  const body = await req.json();
  const item = {
    id: crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2),
    ...body,
    createdAt: new Date().toISOString(),
  };
  memoryStore.unshift(item);
  return NextResponse.json(item, { status: 201 });
}
`;

    files.push({
      path: `app/api/${slug}/route.ts`,
      contents: apiRoute,
    });
  });

  // --- Primary entity panel (client component with live data) ----------
  if (primaryEntitySlug) {
    const primaryPanelTsx = `"use client";

import { useEffect, useState } from "react";

type PrimaryItem = {
  id: string;
  title: string;
  note?: string;
  createdAt?: string;
};

export default function PrimaryEntityPanel() {
  const [items, setItems] = useState<PrimaryItem[]>([]);
  const [title, setTitle] = useState("");
  const [note, setNote] = useState("");
  const [loading, setLoading] = useState(false);
  const [submitting, setSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  async function loadItems() {
    setLoading(true);
    setError(null);
    try {
      const res = await fetch("/api/${primaryEntitySlug}");
      if (!res.ok) throw new Error("Failed to load items");
      const data = await res.json();
      setItems(Array.isArray(data) ? data : []);
    } catch (err: any) {
      setError(err.message || "Failed to load items");
    } finally {
      setLoading(false);
    }
  }

  useEffect(() => {
    void loadItems();
  }, []);

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault();
    if (!title.trim()) return;
    setSubmitting(true);
    setError(null);
    try {
      const res = await fetch("/api/${primaryEntitySlug}", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ title, note }),
      });
      if (!res.ok) throw new Error("Failed to create item");
      const created = await res.json();
      setItems((prev) => [created, ...prev]);
      setTitle("");
      setNote("");
    } catch (err: any) {
      setError(err.message || "Failed to create item");
    } finally {
      setSubmitting(false);
    }
  }

  return (
    <div className="space-y-3">
      <form onSubmit={handleSubmit} className="space-y-2">
        <div className="flex flex-col gap-1">
          <label className="text-[11px] text-slate-400">
            ${primaryEntityLabel} title
          </label>
          <input
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            placeholder="Quick note / title"
            className="w-full rounded-lg border border-slate-700 bg-slate-900 px-3 py-1.5 text-xs text-slate-100 placeholder:text-slate-600 focus:border-sky-500 focus:outline-none focus:ring-1 focus:ring-sky-500/60"
          />
        </div>
        <div className="flex flex-col gap-1">
          <label className="text-[11px] text-slate-400">
            Notes (optional)
          </label>
          <textarea
            value={note}
            onChange={(e) => setNote(e.target.value)}
            rows={2}
            placeholder="Context, next steps, or anything else."
            className="w-full rounded-lg border border-slate-700 bg-slate-900 px-3 py-1.5 text-xs text-slate-100 placeholder:text-slate-600 focus:border-sky-500 focus:outline-none focus:ring-1 focus:ring-sky-500/60"
          />
        </div>
        <div className="flex items-center justify-between gap-2">
          <button
            type="submit"
            disabled={submitting || !title.trim()}
            className="inline-flex items-center gap-1 rounded-xl bg-sky-600 px-3 py-1.5 text-[11px] font-semibold text-white shadow-sm hover:bg-sky-500 disabled:cursor-not-allowed disabled:bg-slate-700"
          >
            {submitting ? "Saving..." : "Add ${primaryEntityLabel}"}
          </button>
          {loading && (
            <span className="text-[10px] text-slate-500">
              Refreshing...
            </span>
          )}
        </div>
        {error && (
          <p className="text-[11px] text-rose-300">
            {error}
          </p>
        )}
      </form>

      <div className="rounded-lg border border-slate-800 bg-slate-950/80 p-3">
        <div className="mb-2 flex items-center justify-between gap-2">
          <p className="text-[11px] font-semibold text-slate-200">
            Recent ${primaryEntityLabel}s
          </p>
          <button
            type="button"
            onClick={loadItems}
            className="text-[10px] text-sky-400 hover:text-sky-300 underline-offset-2 hover:underline"
          >
            Refresh
          </button>
        </div>
        {items.length === 0 ? (
          <p className="text-[11px] text-slate-500">
            No ${primaryEntityLabel.toLowerCase()}s yet. Create the first one above.
          </p>
        ) : (
          <ul className="space-y-1.5 max-h-48 overflow-y-auto pr-1">
            {items.map((item) => (
              <li
                key={item.id}
                className="rounded-md border border-slate-800 bg-slate-950 px-2 py-1.5"
              >
                <p className="text-[11px] font-medium text-slate-100 line-clamp-1">
                  {item.title || "(untitled)"}
                </p>
                {item.note && (
                  <p className="text-[10px] text-slate-400 line-clamp-2">
                    {item.note}
                  </p>
                )}
                {item.createdAt && (
                  <p className="mt-0.5 text-[9px] text-slate-500">
                    {new Date(item.createdAt).toLocaleString()}
                  </p>
                )}
              </li>
            ))}
          </ul>
        )}
      </div>
    </div>
  );
}
`;

    files.push({
      path: "app/components/PrimaryEntityPanel.tsx",
      contents: primaryPanelTsx,
    });
  }

  // --- Simple README ---------------------------------------------------
  const readme = `# ${projectName} · Generated by Zero17 Builder Lab

This folder was generated automatically from:

- Multi-Lens Spec (Founder / Architect / QA / Client / Agent)
- Architecture Map (screens, entities, infra)
- Zero17 Builder Lab · Build Engine v1

## Structure

- \`app/layout.tsx\` — Global layout, shell and chrome
- \`app/page.tsx\` — Command Deck (home) + optional Primary Entity panel
- \`app/[screen]/page.tsx\` — One page per Architecture screen
- \`app/api/[entity]/route.ts\` — Simple in-memory API routes per entity
- \`lib/domain/entities.ts\` — Domain types inferred from Architecture entities

## Next steps

- Replace in-memory APIs with your real database
- Wire auth, monitoring and CI via the Deployment Plan
- Refine copy and components to match your brand
- Add more tests based on QA Lens

> Zero17's job: get you to a serious starting point in minutes.
> Your job: make it legendary.
`;

  files.push({
    path: "README.md",
    contents: readme,
  });

  return files;
}

/**
 * Write generated files to /generated/{projectId} at the repo root.
 * This is intended for local dev (Cursor, Node runtime), not Vercel serverless.
 */
export async function writeGeneratedProject(
  projectId: string,
  files: GeneratedFile[]
): Promise<WriteResult> {
  const rootDir = path.join(process.cwd(), "generated", projectId);

  // Clean existing dir if present
  await fs.rm(rootDir, { recursive: true, force: true });

  for (const file of files) {
    const filePath = path.join(rootDir, file.path);
    const dir = path.dirname(filePath);

    await fs.mkdir(dir, { recursive: true });
    await fs.writeFile(filePath, file.contents, "utf8");
  }

  return {
    rootDir,
    fileCount: files.length,
  };
}
